\documentclass[journal]{../IEEEtran}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{epsfig} % for postscript graphics files
\usepackage{graphics} % for pdf, bitmapped graphics files

\graphicspath{{Figures/}}

\pagestyle{fancy}
\lhead{CPE 470/670}
\rhead{\thepage}
\chead{Team 6: Lab 7 Report}
\lfoot{}
\rfoot{}
\cfoot{}

\begin{document}

\begin{titlepage}
    \vspace*{\fill}
    \begin{center}
      {\LARGE \bf Lab 7: Soccer Robot}

      {Team 6: Alexander  C. Woods and Taylor Mansfield}

      December 12, 2014
    \end{center}
    \vspace*{\fill}
  \end{titlepage}


\section{Hardware and Software Design}\label{S.design}
\IEEEPARstart{P}{laying} soccer with a robot is a fun and interesting challenge. The robot must be able to sense the location of the ball, determine whether or not it should be attacking or defending, and act accordingly. The field on which the robots played is shown in Fig.~\ref{F.field}. The field consists of a goal on each end, which span the entire width. The goals are marked by black zones and the ball must completely enter the zone in order to be considered a point.

\begin{figure}[ht]
\centering
\includegraphics[width=1\columnwidth]{field.eps}\\
\caption{The field on which the robots play soccer has a goal on each end which spans the entire width marked by black zones.}
\label{F.field}
\end{figure}

The sensors used for this challenge are quite simple. An IR sensor is used to detect the location of the ball according to the map shown in Fig.~\ref{F.ir_map}. The only other sensor used in this challenge is a compass sensor which is used to determine the heading of the robot. This is important so that the robot can determine whether or not it should be attacking, or defending.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\columnwidth]{ir_map.eps}\\
\caption{The IR detector reports which zone the ball lies in, as well as the intensity of the reading.}
\label{F.ir_map}
\end{figure}

Other than sensors, the hardware design for this robot is very simple. To make the robot faster the wheels are geared for speed, and for maneuverability the robots center of gravity is kept as low as possible.

The software design for this project includes three distinct parts. A normal play mode, a goalie mode, and a penalty shooter mode. During the normal play mode the robot uses relative angle of the ball to its centerline and its own heading to determine whether it should be on offense or defense according to the sum of the heading and relative ball position. When attacking, the robot should drive straight at the ball in order to kick it toward the opponents goals. When defending, the robot should loop back around the ball such that it wouldn't score an own goal.

For the goalie program, the robot simply tried to keep the ball in zone 2, by moving parallel to the goal line. If the ball moved into a zone greater than 2, the robot moved forward and if the ball moved into a zone less than 2, the robot moved backwards. For the penalty kicker program, the robot simply performed normal attack behavior - drive straight at the ball to kick it at the opponent goal.

\section{Problems Encountered}\label{S.problems}

To begin, we needed a software design to detect and move toward the IR ball. Due to the lack of granularity with the provided sensor and the degree of control we had over the motors, we had some trouble coupling the sensor input to the power of the motors in an effective and meaningful way.

Regarding the form factor of the robot, it was constantly up for debate and restructuring. We had to meet the demands of effectiveness, stability, simplicity, and minimum weight.

We had an issue with backing up from a wall, should we ever run into it, in which the regulation of the power to the wheels prevented them from stopping, which caused the odometry watch to not trigger the backup procedure.

We also had an issue where the robot would behave in a very unexpected way and instead of kicking the ball, would retrieve it and project it toward its own goal.

\section{Solutions}\label{S.solutions}

To drive the motors, we initially tried PID control with input from the IR sensor dir value. This worked mildly well, but had limitations when going up to the ball. We found that there was a serpentining effect when the robot would get close to the ball. In some cases the robot would get really close to the ball and stop short of actually touching it. 

After many iterations, additions, subtractions, and adjustments, we finally came up with a design that would follow our proposed gameplay strategy effectively. With a simple wedge tapering to forward sections, our robot could kick the ball in a random direction downfield (sometimes away from other players), hold the ball against the wall, and with some implementations of software, handle the ball very nicely.

We also attempted to couple the speed of the motors to the observed distance away from the ball, but that implementation had similar problems, especially when trying to overcome an obstacle such as a wall where the robot could not provide enough torque with this algorithm to move past the wall if the ball was close enough to the robot.

We even tried a more simple method of porportional control with different functions applying to different ranges in the sensor direction imput, but while that seemed effective, it drastically lowered the speed of the robot to the point where it was uncompetitive with other robots.

Instead, we went with a case switch statement where we manually set a static value power to the motors, mirrored over the IR sensor's range of directional values and increased in power and decreased in power ratio as the sensor direction approached the forward range. This seemed to have the most effective results, although it was also not perfect (see below).

\section{Unsolved Problems}\label{S.unsolved}

Unfortuantely, we never did solve the issue of the unexpected ball retrieval. In some instances, the ball would be kicked into the opponents goal as normal, whereas in other cases the robot would immediately retieve the ball from the center of the field. This behavior appears to be essentially random, and more fine tuning of the motor speed tied to the sensor input might have fixed the issue. regulating the speed of the motor may have also helped, but that would have caused more issues with recovering from sticking to walls.

\end{document}
